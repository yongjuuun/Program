### 프로그래머스_Lv2_방문길이
1. 풀이방법
   - x, y 축 +5, -5 의 크기로 같은 길을 지나가는걸 제외한 지나간 길의 수 구하기
   - 이동 전의 x 좌표, y좌료, 이동 후의 x 좌표, y 좌표를 숫자 그대로 String 으로 변환 후 HashMap 의 Key 값으로 저장
   - 동일한 key 값이 없을 경우 해당 이동 경로 저장해주고 있을 경우 대략 count 만 증가해주고 넘어가기
   - 이동했을 때 좌표를 초과하게 되면 이동하지 않도록 추가
   - 1차 실패 요인 => x, y 축으로 한칸 씩 이동하게 될경우 돌아오는 경로도 지나갔던 길로 판정해서 answer 추가 되지 않도록 수정

2. 자료 구조 사용 이유
   1. HashMap
      - 이동전, 후의 좌표를 지나갔는지 체크하기 위해 사용
      - Set 으로 대체해서 수정해도 될 것 같음

3. 주의
   - 이동전 -> 이동후 의 경로와 이동후 -> 이동전 경로는 같은 경로로 취급해서 카운트 조절 필요



### 프로그래머스_Lv2_땅따먹기
1. 풀이방법
   - DP(Dynamic Programming) 풀이법 사용
   - 다음 배열에서 동일한 인덱스를 제외하고 합을 계산해야 하므로 두번째 인덱스부터 시작해서 이전 배열의 최대합을 계산해서 그 자리에 저장
   - Math.max 를 사용해서 배열의 해당 자리에서 나올 수 있는 최대값을 구하고 그 값중 최대값을 출력

2. 자료 구조 사용 이유
   1. DP - 다이나믹 프로그래밍
      - 전체 탐색이 필요할 때
      - 경우의 수를 직접 계산해서 경우의 수가 dfs 는 약 500만개 이하로 잡고, 그 이상은 dp 로 풀이 필요
      - 경우의 수들 중에서 중복적인 연산이 많을 경우 주로 사용



### 프로그래머스_Lv2_스킬트리
1. 풀이방법
   - skill 순서를 split 으로 분리하고 ArrayList 에 저장
   - skill_trees 를 같은 방법으로 다른 ArrayList 에 저장
   - 우선 주어진 skill 배열에서 정해진 skill 에 포함되지 않는 skill 을 모두 제거 한 후 남은 스킬 비교
   - 



### 프로그래머스_Lv2_할인행사
1. 풀이방법
   - 10일 동안의 할인 음식이 원하는 음식의 수량과 같은지 체크하기 위하여 10 일치 음식을 HashMap 에 저장
   - 원하는 음식을 카운트업 해주면서 HashMap 에 저장
   - 반복문을 실행해 원하는 음식의 개수와 할인 음식이 같으면 count 에 누적 저장
   - 누적이 다 되었을 때 일치하면 count 가 10 이 되어야 하므로 10 일 때 answer 증가
   - 다음 반복문 실행시 제일 앞의 음식을 한개 제거하고 그 다음 음식을 한개 추가 하도록 설정

2. 자료 구조 사용 이유
   1. HashMap
      - 원하는 음식과 개수를 저장하고, 할인하는 음식과 그 개수를 저장하고 비교하기 위해서 사용

3. 개선, 주의, 궁금
   - 마지막 반복문 실행시 map 에 제거, 추가 할 때 저장만 하고 계산을 실행하지 못하는 부분에 대하여 해결책 필요



### 프로그래머스_Lv2_주식가격
1. 풀이방법
   - prices 의 크기만큼 반복문 실행
   - 이중 반복문을 생성하여 실행중인 값의 다음값들과 비교해서 값이 떨어지는지 체크



### 프로그래머스_Lv2_주차요금계산 (50%) (*)
1. 풀이방법
   - HashMap 과 TreeMap 을 두개 선언
   - records 크기 만큼 반복문을 돌리며 split 으로 나누어 시간을 분으로 환산
   - HashMap 에 저장이 안되어 있으면 입차, 저장이 되어있으면 출차 처리하며 TreeMap 에 요금계산 저장
   - 출차 시 HashMap 에서 삭제
   - 출차 시간이 표시 안된 경우 11시 59분을 고정값으로 요금 계산
   - TreeMap 에 존재하는 값들을 불러와 반올림 하여 기본시간, 초과값에 대하여 계산

2. 자료 구조 사용 이유
   1. HashMap
      - key 값을 차량 번호, value 값을 시간 으로 저장하고 입/출차를 계산하기 위해서 사용
   2. TreeMap
      - key 값을 차량 번호, value 값을 시간 으로 저장하고 요금을 계산하기 위해서 사용
      - HashMap 과 다르게 값이 들어올 때 key(차량번호)값을 기준으로 자동 정렬해주기 때문에 사용
   3. Math.ceil
      - 시간단위로 나눴을 때 나온 값을 올림처리하여 계산하기 위하여 사용
      - double 형으로 변환 주의

3. 개선 및 주의
   - 프로그래머스 테스트 케이스 50% 성공, 에러 케이스 반례를 찾지 못함



### 프로그래머스_Lv1_삼총사 (*)
1. 풀이 방법
   - dfs 깊이 우선 탐색법 사용
   - 재귀함수를 돌리며 1회 깊게 들어갈 때마다 count 증가
   - count 가 3이 돼었을 때, temp 배열에 들어있던 숫자 3개의 총합이 0 이면 answer 증가
    
2. 자료 구조 사용 이유
   1. dfs - 재귀함수
      - 모든 경우의 수로 3개의 합을 구해보고 총 합이 0 인 갯수를 구하는 문제이기 때문에 dfs 재귀함수 사용

3. 개선 및 주의
   - 재귀함수 들어가는 부분에서 index 인자에 i 의 숫자를 넣어줘야 하는데 index 의 숫자를 넣는 실수를 함



### 프로그래머스_Lv2_3차 n진수 게임
1. 풀이 방법
   - num 을 선언하고 0 부터 t(미리 구할 숫자 갯수) * m(참가 인원) 까지 n 진법으로 변환 후 저장
   - p(튜브의 순서)가 1이면 index 0 번째 부터 answer 에 넣어줘야 하기 때문에 i 를 p - 1 부터 시작해서 문자를 하나씩 저장 해준다
   - answer 의 길이가 t 이상이 되면 반복문을 중지 시킨다
   - toString 으로 변환시 10 이상의 숫자에서 알파벳 소문자로 변환되지만 요구하는 정답은 대문자이기 떄문에 answer 를 대문자로 변환해준다

2. 자료 구조 사용 이유
   1. StringBuffer
      - 게임에 참가인원과 미리 구할 숫자의 갯수가 커지게 될 경우 일반 문자열에 저장하는 것보다 효율성 증가
   2. Integer.toString(a, b)
      - 자바의 내장되어 있는 기능 중 하나로 a를 b 진법으로 변환하기 위해 사용
   3. str.toUpperCase()
      - 소문자를 대문자로 변환 시켜 줄 때 사용
      - answer.toLowerCase() 는 대문자를 소문자로 변환 시켜 줄 때 사용



### 프로그래머스_Lv2_오픈채팅방
1. 풀이 방법
   - Map 을 선언하여 id 와 nickname 을 key, value 값으로 저장
   - 주어진 record 배열을 반복문으로 돌리며 띄어쓰기를 기준으로 split 해서 temp 배열에 저장
   - temp 의 배열 첫번째 요소에 따라서 Enter, Leave, Change 로 명령을 구분하여 hashmap 에 id, nickname 저장
   - change 를 했을 경우에는 결과값에 남지 않기 때문에 answer 에 change 인 경우 제외하고 저장
   - change 를 하면 기존에 hashMap 에 저장 되어 있던 value 값 수정
   - 다시 record 를 split 해서 Enter 와 Leave 일때만 입장, 퇴장 출력

2. 자료 구조 사용 이유
   1. HashMap
      - id 와 nickname 을 구분하여 id 에 따른 nickname 을 출력해주기 위해서 사용
      - id 는 고유하므로 change 명령시에 기존에 저장되어 있던 id 의 value 값인 nickname 을 수정해주기 위해서 사용
   
   2. split
      - 문제에서 주어진 String 배열의 문장을 띄어쓰기로 구분하여 명령, id, nickname 으로 나눠서 용도에 맞게 사용



### 프로그래머스_Lv2_피로도_dfs
1. 풀이 방법
   - for 문으로 반복문을 실행하면서 재방문을 방지하기 위해서 boolean visit 을 선언
   - dfs 풀이법을 사용하여 dungeons 의 크기만큼 재귀함수를 실행
   - 주어진 배열의 인덱스를 하나씩 올려가며 방문하지 않았고, 이중배열의 첫번째 값(최소 필요 피로도)이 k보다 작으면
      이중 배열의 두번째 값(소모 피로도)을 빼준다
   - answer 에는 최대로 많이간 던전 수를 입력하기 위해 index, answer 두 개를 계속 비교해서 높은 수를 넣어준다

2. 자료 구조 사용 이유
   1. dfs, 재귀함수
      - 완전 탐색 방법 중 깊이 우선 탐색을 사용한 풀이
      - 최대 클리어 던전 횟수를 구하기 위해서 재방문을 막고 모든 경우의 수를 확인하기 위해 사용

3. 개선
   // 궁금점 - 만약에 answer = dungeons.length(최대인덱스) 가 됐을 때 더이상 안돌려도 되는거 아닌지? 무조건 나머지 다 도는 구조인가



### 프로그래머스_Lv2_더 맵게
1. 풀이 방법
   - PriorityQueue 으로 우선순위 탐색으로 풀이
   - scoville 를 PriorityQueue 에 모두 입력
   - Queue 의 크기가 2 미만 일 때 까지 반복문 실행
   - 가장 앞의 값(가장 작은 값)이 K 보다 크다면 모두 K 이상이므로 반복문 break
   - 가장 작은수와 그 다음 작은 수를 mixScov 에 계산해서 입력하며 계산할 때마다 카운트 증가
   - Queue 의 크기가 2 보다 작으면서, 남은 수가 K 보다 아래여서 더 계산이 불가능 한 경우 -1 return

2. 자료 구조 사용 이유
   1. PriorityQueue<>
      - 우선순위 큐를 사용하여 가장 작은 숫자를 O(log N) 의 시간복잡도로 보다 빠르게 처리하기 위해서 사용
   


### 프로그래머스_Lv2_연속 부분 수열 합 개수



### 프로그래머스_Lv2_귤 고르기
1. 풀이 방법
   - HashMap 을 선언하여 배열의 각 숫자를 key 값으로, 숫자의 개수를 value 값으로 저장
   - ArrayList 를 sort 하여 value 값이 높은 순서대로 정렬
   - 배열의 앞에서 부터 타겟넘버인 k 값이 0이하가 될 때 까지 빼며 실행 횟수만큼 answer 카운트 증가

2. 자료 구조 사용 이유
   1. HashMap
      - HashMap 을 사용하여 해당 숫자의 개수를 count 해서 저장하고 그 값을 이용하여 반복문을 사용하기 위해서
   2. sort
      - al.sort(((o1, o2) -> hm.get(o2) - hm.get(o1)));
      - 람다식을 사용하여 HashMap 에 저장되어 있는 value 값을 기준으로 내림차순으로 정렬하기 위해 사용
   


### 프로그래머스_Lv2_타겟넘버(*) 
1. 풀이 방법(차후 재풀이 필요)
   - 풀이 방법이 떠오르지 않아 풀이 참고
   - DFS 풀이 방식으로 DFS/BFS 알고리즘 동작 방식 학습 및 이해
   - 재귀함수 풀이 방법 학습 및 이해

2. 자료 구조 사용 이유
   1. dfs(깊이 우선 탐색)
      - 재귀 함수 또는 스택 자료 구조 이용
      - 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 스택에 넣고 방문 처리 하고, 없으면 츠택에서 최상단 노드를 꺼낸다
      - 경로 탐색, 경우의 수, 조합 만들기 같은 경우에 주로 사용
   


### 프로그래머스_Lv2_전화번호 목록
1. 풀이 방법
   1. 1차 풀이 방법
      - 2 중 for 문을 활용하여 비교할 문자열을 substring 으로 앞에서부터 길이만큼 자른 후 equals 비교  
         => 시간복잡도 상승, 효율성 저조로 인해 수정필요
   2. 2차 풀이 방법
      - sort 를 사용하여 for 문을 한개만 사용해서 다른 요소들과 비교하며 풀이  
         => 일부 테스트 케이스 런타임 에러 발생
      - startWith 를 사용하여 접두사에 문자가 포함되는지 체크 후 결과 값 리턴

2. 자료 구조 사용 이유
   1. Arrays.sort()
      - string 을 사전 형식으로 정렬을 해야 배열의 다음 요소의 접두사만 체크를 해도 돼서 시간 단축
   2. startWith
      - 문자열이 접두사에 포함되는지를 확인하는 문제이기 때문에 해당 메소드 사용으로 효율성 상승
      


### 프로그래머스_Lv2_3차 압축
1. 풀이 방법(풀이 일부 참고, 차후 재풀이 필요)
   - HashMap 을 사용하여 알파벳과 index 번호를 매칭시킨 값을 저장
   - A ~ Z 까지의 기본 알파벳을 for 문을 사용하여 초기화 용도로 저장
   - 반복문을 사용하여 체크 하고자 하는 값이 끝에 도달하면 종료
   - 체크하고자 하는 문자가 index 에 포함되어 있으면 그 다음글자 까지 체크
   - 포함되어 있지 않다면 결과값에 포함되어 있는 문자의 index 번호를 입력
   - 포함되어 있지 않은 문자열을 index 에 추가
   - end 문자는 항상 i + 1 로 다음 문자까지 포함해서 체크

2. 자료 구조 사용 이유
   1. HashMap
      - key 값과 value 값을 함께 저장하여 해당 key 의 value 값을 출력하기 위해 사용
   2. 문자열.substring()
      - 체크하려는 문자열의 범위를 한글자씩 늘려가며 확인하기 위해 사용



### 프로그래머스_Lv2_K 진수에서 소수 개수 구하기
1. 풀이 방법
   - 입력받은 숫자 n 을 입력받은 숫자 k 진수로 변환하여 String 에 입력
   - 변환된 문자열을 '0' 을 기준으로 split 후 저장
   - 소수가 될 수 있는 수는 2 이상이기 때문에 조건문 생성
   - 제곱근을 계산하는 Math.sqrt() 함수를 사용하여 소수 계산
   - 만약 소수로 판별 될 경우 answer 값 + 1 실행 후 최종값 출력

2. 자료 구조 사용 이유
   1. Integer.toString(n, k)
      - n 을 k 진수로 변환 할 수 있는 함수
   2. try ~ catch
      - String 타입의 문자열을 long 타입에 입력하며 NumberFormatException 에러 발생
      - NumberFormatException 에러에 대하여 예외 처리
   3. Math.sqrt()
      - double 타입의 인수를 전달하면 인수에 대한 double 제곱근 값을 리턴
      - 소수를 찾기위한 계산법 중 가장 빠르게 접근 할 수 있는 함수

3. 개선 해야 할 점
   1. try ~ catch 를 사용하지 않고 에러 발생 하지 않도록 수정 필요



### 프로그래머스_Lv2_뉴스 클러스트링
1. 풀이 방법
   - 주어진 문자열을 모두 소문자로 전환
   - 두 글자씩 끊어서 알파벳일 경우에만 각각의 ArrayList temp 에 저장
   - for 문을 활용해 temp2 의 내용이 temp1 에 포함되어 있으면 해당 요소 삭제, 교집합 List 에 추가
   - temp1 + temp2(교집합 제외 요소) 를 합집합 List 에 추가
   - 서로 공집합 일 경우 1 을 넣어주고, 그 외에는 교집합 / 합집합 크기를 계산

2. 자료 구조 사용 이유
   1. ArrayList
      - contains 함수를 사용하고 각각의 저장공간을 만들기 위하여 사용
   2. 자카드 유사도의 값이 0 ~ 1 사이의 실수이기 때문에 double 형으로 계산



### 프로그래머스_Lv2_N^2 배열 자르기
1. 풀이 방법
   - answer 배열을 큰값에서 작은값을 뺀 후 + 1을 한 값으로 크기 지정
   - 행의 값에 행열의 크기인 n 값을 나눈 값을 입력
   - 열의 값에 행열의 크기인 n 값을 나눈 값의 나머지를 입력
   - 행, 열 중 큰 수를 answer 배열에 입력



### 프로그래머스_Lv2_기능 개발
1. 풀이 방법(사용 메소드 참고 풀이, 차후 재풀이 필요)
   1. progresses 의 요소들이 배포 될 수 있는 날짜를 계산 후 Deque 에 저장
      - 남은 날짜 = (100 - progresses) / speeds
      - ex) progresses = 40, speeds = 60 => 남은 날짜 = 1일
      - Math.ceil 을 사용하여 결과값에 대하여 정수형으로 올림 처리

   2. while 문 사용해서 Deque 에 값이 비어있을 때 까지 반복문 실행
      - day 에 Deque poll 값을 넣어준다
      - day 값이 다음 Deque peek 값의 이상이면 배포되는 수인 count 를 올려주고 Deque peek 한 값을 poll 한다.
      - ArrayList 에 count 값을 추가

   3. ArrayList 에 저장 된 값을 int[] answer 배열에 저장 후 출력

2. 자료 구조 사용 이유
   1. Math.ceil
      - 나눈 결과가 소수점이 나올시 올림을 해주지 않으면 남은 날짜가 -1 값이 된다
   2. Deque
      - 저장된 앞의 값 부터 가져오기, 삭제하며 남은 배포 count 를 세기 위해 사용

3. 개선할 점
   1. ArrayList 에 값을 저장 후 answer 에 값을 넣기 위해 for 문을 한번더 사용함으로 인해 저장공간, 효율성 낭비



### 프로그래머스_Lv2_튜플
1. 풀이 방법(사용 메소드 참고 풀이, 차후 재풀이 필요)
   - 입력받은 문자열 s를 분리하기 위하여 replaceAll 정규식, 공백제거 trim 사용
   - sort 사용하여 배열의 길이 순으로 정렬
   - ArrayList 에 먼저 나오는 숫자 순서대로 입력
   - ArrayList -> int 배열 변환

2. 개선
   - ArrayList 에서 int 배열로 값 옮기는 과정에서 불필요한 for 문 사용
   - ArrayList 에 값을 넣어 주는 부분에서 바로 answer 에 값 입력 하도록 수정



### 프로그래머스_Lv2_짝지어 제거하기
1. 최초 풀이(테스트 코드 통과, 효율성 테스트 실패)
   - StringBuffer 사용
   - 두번째 문자열부터 문자열 두개 비교 후 문자 제거

2. 개선
   - Stack(push, pop, empty) 사용 풀이
   - 문자열 길이 불충족시 초기 리턴 추가



### 프로그래머스_Lv2_짝지어 제거하기
1. 최초 풀이(테스트 코드 통과, 효율성 테스트 실패)
   - while 문 사용
   - split 사용 문자 비교
   - 문자 비교에 따른 left, right count 비교로 풀이

2. 개선
   - Stack(push, pop, empty) 사용 풀이
   - charAt() 사용으로 문자 비교